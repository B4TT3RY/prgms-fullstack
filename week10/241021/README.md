# 2024/10/21 10주차 파트 1

프론트엔드 기초: React + Typescript 강의 시작

## 실습 환경

강의에서는 VSCode + iTerm2 + Chrome 사용 예정

## JavaScript 언어의 특징

### 인터프리터

컴퓨터는 사람이 이해한 언어를 기계어로 번역해야 함

번역 방식에는 컴파일러, 인터프리터 방식이 있으나 JavaScript에서는 인터프리터 방식을 사용함

컴파일 단계가 없지만 컴파일러 언어에 비해 실행 속도가 느림

하지만 V8 엔진에서는 속도 개선이 됨

### 그 외

- 동적 타입 언어
  - 변수에 들어가는 값에 따라서 런타임에 타입이 추론됨
- 일급 객체
  - 함수는 일금 객체의 특징을 가짐
  - 함수는 객체와 동일하게 사용할 수 있음
  - 함수는 값과 동일하게 취급함
- 프로토타입 기반의 상속
  - 언어가 갖고 있는 프로토타입 체이닝 구조를 통하여 상속할 수 있음
- 여러 프로그래밍 패러다임 지원
  - 명령형 프로그래밍
  - 함수형 프로그래밍
  - 객체지향 프로그래밍
  - ...

## 변수란?

데이터를 처리하는 과정에서 처리 흐름마다 값들을 기억해둘 필요가 있음

컴퓨터는 데이터를 기억하기위해 메모리를 활용함

변수는 메모리 주소값의 별칭임

메모리 주소값을 대신할 식별자를 지정하고 식별자를 통해서 데이터 접근

즉. 변수란 데이터를 담아둔 메모리의 주소를 쉽게 식별하기 위해 붙인 이름

## 변수 생성 방법과 호이스팅

### 변수의 생성 단계

코드 평가 + 코드 실행 단계에서 진행함

1. 선언 단계
    - 변수를 변수 객체에 등록
1. 초기화 단계
    - 변수를 메모리에 할당하고 undefined로 초기화 함
1. 할당 단계
    - undefined로 초기화된 변수에 실제로 값을 할당함

### 호이스팅이란?

모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성

함수 호이스팅, 변수 호이스팅 등

### var 키워드

- 코드 평가 단계: 선언 진행, 초기화 진행
- 코드 실행 단계: 값 할당 진행
- 코드 평가시점에 초기화가 되어있으므로, 변수의 할당문이 실행되기 전에도 참조가 가능함 (호이스팅)

```js
console.log(a);
console.log(b);

var a = 1;
var b = 2;
```

### var 키워드의 단점

- var 키워드 생략 가능
- 중복 선언 가능
- 변수 호이스팅
- 전역변수화
  - 전역 변수화되어 무분별한 변수 접근
    - 스코프:
      - 코드가 실행이 되는 과정에서 변수와 같은 식별자를 찾아야하는 코드가 있을 때 자바스크립트가 갖고 있는 규칙
      - 전역 스코프 (global), 지역 스코프 (local)
    - 의도치 않은 변수값 변경, 코드 예측이 어려워짐

### const, let 키워드

- 코드 평가 단계: 선언 진행
- 코드 실행 단계: 초기화 진행, 값 할당 진행
- 코드가 평가시점에 선언만 진행되므로 변수의 할당문이 실행되기 전에 참조가 불가능함
- 블록 레벨 스코프
  - 코드 블록 내에서 접근 가능한 스코프
- 변수에 한정적으로 접근이 가능하므로 예측 가능한 범위 내에서 변수 변경이 일어남

### const 키워드

- 수정이 불가능한 상수 변수를 선언할 때 사용
- 무조건 값을 할당

### let 키워드

- 재할당이 가능한 변수 타입
- 값을 할당하지 않아도 생성

## 변수 네이밍 컨벤션

- Camel Case (getNumber)
- Snake Case (get_number)
- Pascal Case (GetNumber)
- Constant Case (GET_NUMBER)

## 데이터 타입

### 원시 타입

자바스크립트는 String, Number, BigInt, Undefined, Null, Boolean, Symbol을 제공함

원시 래퍼 객체가 따로 존재함, 원시 데이터를 사용할 경우 해당 레퍼 객체들을 상속받아 사용할 수 있음.

- 값은 변경 불가능함.
- 값으로써 전달됨

### 객체 타입

- 원시 타입의 값을 제외한 자바스크립트에서의 모든것은 객체임
- 객체는 참조 방식으로 전달됨
- 객체는 속성들을 변경할 수 있는 mutable한 값임

### Number Type

- 정수는 존재하지 않음, 모든 숫자를 실수로 처리함
- 배정밀도 64비트 부동소수점 (IEEE 754) 형식
- 실수를 연산할 때 근사값으로 처리함
- Infinity와 NaN (Not A Number)이라는 값도 존재함

### BigInt Type

- 임의 정밀도로 정수를 나타낼 수 있음
- Number의 최대값을 넘는 정수도 안전하게 저장하고 연산할 수 있음
- 다른 타입과 혼합하여 연산할 수 없음

### String Type

- 텍스트 데이터를 나타날 때 사용
- UTF-16 코드 단위의 시퀀스로 표현
- 문자값(원시값)은 불변함
- 따옴표, 쌍따옴표, 백팃으로 감싸서 문자열임을 표현함
- 백팃은 ES6 이후부터 사용 가능
  - String interpolation

### Boolean Type

- 논리적 데이터 유형
- 참 혹은 거짓의 값만 가질 수 있음

### undefined

- 변수를 선언한 후 값을 할당하지 않은 변수에 할당이 되는 값

### null Type

- 값이 없다는 것을 의도적으로 표현할 때 사용
- 이전에 참조되어있던 값을 의도적으로 더이상 참조하지 않겠다는 뜻으로도 사용됨
- null 타입 체크는 일치연산자 (`===`) 사용을 권장함
  - null의 타입이 object 라고 나오는데 버그이기 때문

### Symbol Type

- ES6부터 추가된 타입
- 중복되지 않는 유니크한 값
  - 객체의 key로 사용될 수 있음
  - 클래스나 객체형식의 내부에서만 접근할 수 있도록 전용 객체 속성의 키로 사용

### Reference Type

- 객체 타입, Object type, Reference type
- 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조
- 원시 타입의 값을 제외한 모든 것은 객체

#### mutable

- 변경 가능한 값
  - 객체의 속성을 변경, 추가, 삭제 가능
- 힙 메모리에 저장
- Pass-by-reference
  - 참조 타입이므로, 참조 값으로 처리

### 동적 타입 언어

- 자바스크립트는 동적 타입 언어
- 의도적으로 타입을 변호나할 수 있지만, 의도와 상관없이 변경되기도 함
  - 명시적 타입 변환
  - 암묵적 타입 변환
- 원시 래퍼 객체를 활용하여 개발자가 의도적으로 타입을 변경할 수 있음
  - `값.toString()`
  - `Number(값)`
  - `Boolean(값)`

#### 암묵적 타입 변환

- `값 + ""`: 문자열 타입으로 변환
- `값 * 1`: 숫자 타입으로 변환
- `!!값`: 불리언 타입으로 변환

#### 해결법

- 전달되는 시점마다 typeof나 일치연산자를 사용하여 타입 guard를 구현하거나
- 자바스크립트 superSet인 타입스크립트를 사용

## 연산자란?

하나 이상의 표현식을 대상으로 연산을 수행하여 하나의 값을 만듬

- 단항 연산자
- 산술 연산자
- 관계 연산자
- 이진 논리 연산자
- 삼항 연산자
- 할당 연산자
- 옵셔널 연산자
- 쉼표 연산자

### 단항 연산자

하나의 피연산자만 사용하는 연산

- `void`: 표현식을 평가할 때 값을 반환하지 않도록 지정
- `typeof`: 평가 전의 피연산자 타입을 나타내는 문자열을 반환
- `delete`: 객체의 속성을 삭제

### 산술 연산자

두 개의 숫자 값을 피연산자로 받아서 하나의 숫자 값을 반환함

#### 단항 산술 연산자

1개의 피연산자를 산술 연산하여 숫자값을 반환함

- `++`: 숫자 1을 증가시키고 증가시킨 값을 암묵적으로 할당
- `--`: 숫자 1을 감소시키고 증가시킨 값을 암묵적으로 할당
- `+`: 양수의 표현
- `-`: 양수를 음수로, 음수를 양수로 반전시킨 값을 반환
- 전위 증가감소 연산자
  - 피연산자 앞에 위치
- 후위 증가감소 연산자
  - 피연산자 뒤에 위치

#### 이항 산술 연산자

2개의 피연산자를 산술 연산하여 숫자값을 반환

`+`, `-`, `*`, `/`, `%`가 존재

### 관계 연산자

피연산자를 비교하고 결과가 참인지에 따라 boolean 값을 반환함

- `in`: 객체 내에 속성이 존재할 경우 true 반환
- `instanceof`: 특정 객체 타입에 속하면 true를 반환

### 비교 연산자

피연산자를 비교하고 결과가 참인지에 따라 boolean 값을 반환함

피연산자에는 숫자, 문자열, 논리형, 객체타입이 될 수 있음

- `==`: 동등 연산자, 서로 같으면 true
- `===`: 일치 연산자, 서로 같고 타입도 같으면 true
- `!=`: 부동 연산자: 서로 다르면 true
- `!==`: 불일치 연산자: 서로 다르고 타입도 다르면 true
- `>`: 큼 연산자, 왼쪽이 오른쪽보다 크면 true
- `>=`: 크거나 같은 연산자, 왼쪽이 오른쪽보다 크거나 같으면 true
- `<`: 작음 연산자, 오른쪽이 왼쪽보다 크면 true
- `<=`: 오른쪽이 왼쪽보다 크거나 같으면 true

### 논리 연산자

두개의 치연산자 중 하나를 반환

반환되는 값이 무조건 Boolean 값은 아님

단축평가 논리: 첫번째 식을 평가한 결과에 따라서 두번째 식 쳥가를 진행

- `A && B`: AND 연산자, A가 false로 평가되면 A를 반환, A가 true로 평가되면 B를 반환
- `A || B`: OR 연산자, A가 false로 평가되면 B를 반환, A가 true로 평가되면 A를 반환

- null, undefined, 빈 문자열은 false로 평가됨
- AND 연산자: null 검사에 활용
- OR 연산자: 캐싱 값에 대해서도 사용

### 기타 연산자들

- 쉼표 연산자: 두 연산자를 모두 평가한 후, 오른쪽 피연산자의 값을 반환
- 문자열 연산자: 두 문자열 값을 서로 연결하여 새로운 문자열을 반환
- 옵셔널 연산자: 객체의 속성을 참조시 유효하지 않는 경우 에러를 발생시키지 않고 undefined를 반환
- 할당 연산자: 오른쪽 피연산자가 왼쪽 피연산자에 값을 할당함
  - `+=`, `-=`, `*=`, `/=`, `%=`, `**=` (거듭제곱), `&&=` (논리 AND), `||=` (논리 OR)
- 삼항 연산자: 조건 연산자에 따라 두 값중 하나를 반환함

## 데이터 처리 : 함수

소프트웨어에서 특정 동작을 수행하는 코드 일부분을 의미

외부 코드가 호출할 수 있는 하위 프로그램

대부분의 언어에서 지원함

### JavaScript에서

객체처럼 속성과 메소드를 가질 수 있음

일급 객체의 특징을 모두 갖고 있음

#### 일금 객체란?

다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킴

- 함수의 실제 매개변수가 될 수 있다
- 함수의 반환값이 될 수 있다
- 할당 명령문의 대상이 될 수 있다
- 동일 비교의 대상이 될 수 있다
