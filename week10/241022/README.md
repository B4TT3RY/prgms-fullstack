# 2024/10/22 10주차 파트 2

## Flow Control

특정 Trigger로 시작해 종료되기까지의 흐름이 존재함

컴퓨터는 이 흐름별로 상황을 제어해야 함

Flow Control은 명령형 프로그램의 개별 명령문, 명령 또는 함수 호출이 실행되거나 평가되는 순서임

총 5가지의 제어흐름 종류가 있음

- ~~goto: 다른 구문에서 시작~~
- choice: 일부 조건이 충족되는 경우에만 일련의 명령문 실행
- loop: 어떤 조건이 충족될 때까지 일련의 명령문을 0회 이상 실행
- continue: 현재 실행 구문에서 떨어진 한 구문의 집합을 실행
- break: 프로그램 실행을 중단

## 표현식 (Expression)

어떤 값으로 이행되는 임의의 유효한 코드 단위

표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조

값으로 평가될 수 있는 문은 모두 표현식

리터럴 표현식, 함수 표현식, ...

## 문 (Statement)

프로그램을 구성하는 기본 단위, 최소 실행 단위

선언문, 할당문, 제어문, 반복문, 블럭문, ...

## 블럭문 (Block Statement)

명령문들을 그룹으로 묶을 수 있는 블럭문

한 쌍의 중괄호로 묶어서 표현

## 예외 상황

런타임 때 발생할 수 있는 의도치 않은 상황

흐름 제어 시 발생할 수 있는 예외 상황이므로, 이를 이해하여 코드 레벨에서 대응해야 함

예외 상황을 핸들링하지 않는다면 기능이 동작하지 않거나 어플리케이션이 shutdown 될 수 있음

## 에러 Catch

예외가 발생하면

1. 현재 함수의 실행 중지
1. 에러 객체와 함께 에러가 throw
1. 제어 흐름
    - 호출자 사이에 catch 블럭이 있으면 catch 블럭으로 전달
    - 호출자 사이에 catch 블럭이 없으면 프로그램 종료

에러를 catch하여 프로그램이 종료되지 않도록 해야함

예외 처리를 담당하는 핸들러를 찾기 위해 순서대로 콜 스택을 거슬러 올라가 올바른 핸들러를 찾아내어 그 곳에서 처리되도록 함

## 콜 스택 (Call Stack)

- 스택 자료구조
  - 출입구가 하나인 데이터 구조 (First In First Out)
- Call Stack
  - 코드가 실행되면 생성되는 실행 컨텍스트를 저장하는 자료구조
  - 함수를 호출할 때마다 스택이 쌓이고 함수의 실행이 종료되면 콜스택에서 스택을 제거하는 원리
- 에러가 throw 되면
  - 콜 스택을 확인하여 핸들링 하고 있는 catch 문이 있는 스택에서 처리

## 객체 (Object)

객체는 속성을 가진 독립적인 개체 (entity)

객체는 속성(property)으로 구성된 집합임

자바스크립트는 객체 기반의 프로그래밍 언어

### 객체 속성 (Object property)

속성은 키와 값 사이의 연결 관계 (Key - Value)

객체의 속성은 JavaScirpt의 변수와 유사한데 객체에 속해있음

속성에는 값 뿐만 아니라 함수도 할당 가능함

객체에 속해있는 함수를 method라고 함

### 생성 방법

#### 1. 리터럴 표기

```js
const foo = { name: 'apple' };
```

#### 2. 생성자 함수

속성만 같고 값만 다른 객체를 여러개 생성해야 할 때 번거로움이 있음

템플릿처럼 사용하여 속성이 동일한 객체를 여러개 생성할 수 있다

#### 3. Object.create

생성자 함수처럼 동일한 속성값을 갖는 객체를 생성할 수 있음

### 속성 Control

원시타입과 다르게 변경 가능한 값

객체는 전달하는 과정에서 참조형태로 전달됨

#### 속성 나열하기

1. for...in
    - 모든 열거 가능한 속성을 순회함
1. Object.keys(객체)
    - 객체 자신의 열거 가능한 속성 이름을 배열로 반환
1. Object.getOwnPropertyNames(객체)
    - 객체 자신만의 모든 속성을 배열로 반환

#### 속성 삭제하기

delete 연산자로 속성 삭제

### 객체 비교와 복사

객체는 참조타입임 (Reference Type)

모든 연산이 참조값(메모리 주소)으로 처리

객체를 서로 비교하면 객체 속성과 값이 같은 객체여도 참조값이 다르므로 서로 다름

#### 동일한 객체를 생성해야할 때

정의된 객체를 다른 변수에 그대로 할당할 경우 동일한 메모리 주소만 할당됨

둘 중 하나의 객체를 수정한다면 동일한 메모리 주소이기 때문에 두 변수가 참조하고 있는 객체가 수정되어 결과적으로 두 객체 모두 변경사항에 영향을 받음

복사 방법에는 얕은 복사와 깊은 복사가 있음

#### 얕은 복사 (Shallow Copy)

복사된 객체의 속성 중 하나라도 같은 참조를 하고 있게되면 얕은 복사로 복사되었다고 함

객체의 속성 중 참조타입이 없는 경우에만 얕은 복사 방법 권장

- 방법
  - Object.assign({}, 복사할 객체)
  - { ...복사할 객체 } (spread 연산자)

#### 깊은 복사 (Deep Copy)

복사된 객체의 속성 중 하나라도 같은 참조를 하고 있는 속성이 없다면 깊은 복사로 복사되었다고 함

- 방법
  - 재귀함수를 이용한 복사 (lodash - cloneDeep)
  - JSON.stringify (객체 -> 문자열로 변환 (참조가 끊어짐) -> 객체로 변환)

## 정규 표현식

문자열에서 특정 문자 조합을 찾기 위한 패턴

`/pattern/flags` 형식

### 정규 표현식 생성 방법

- 리터럴 표기법
  - 평가할때 정규 표현식을 컴파일
  - 정규식이 변하지 않으면 리터럴 표기법 사용
  - `/pattern/flag`
- RegExp 객체
  - 런타임 때 컴파일됨
  - 패턴이 변할 가능성이 있거나 알 수 없는 데이터에서 가져오는 정규식의 경우 생성자 함수 사용
  - `new RegExp(/pattern/, flag)`

## Collection

### Array

이름과 인덱스ㅊ로 참조되어 정렬된 값들의 집합

자바스크립트에서는 명시적인 배열 데이터 타입을 갖고 있지 않음

- 생성 방법
  - 배열 리터럴: `[]`
  - Array 객체 생성자
    - `new Array(arrayLength)`: 길이만 지정된 배열 (정수만 가능)
    - `new Array(element0, element1, ...)`: 요소가 지정된 배열

### Map

간단한 키와 값을 서로 매핑시켜 저장하고 저장된 순서대로 요소를 반복적으로 접근할 수 있음

[key, value]의 형태로 삽입된 순서대로 추가

### Set

중복된 값을 허용하지 않음

배열을 인자로 받을 수 있음

## JSON

JavaScript Object Notation

- 인터넷에서 자료를 주고받을 때 자료를 표현하는 방법으로 알려져있음
- 키-값 쌍, 배열 자료형, 기타 모든 직렬화 가능한 값 또는 키-값 쌍으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 open standard 포맷

## 국제화 (Intl 객체)

각 언어에 맞는 문자, 숫자, 시간, 날짜 비교를 제공하는 국제화 API를 위한 namespace

## 객체 지향 프로그래밍

객체는 현실의 개념을 추상화하여 정의

객체라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식

## 프로토타입 객체

객체의 인스턴스를 만드는 부모 객체 개념

자바스크립트의 모든 객체는 부모 객체인 프로토타입 객체와 연결

부모 객체의 속성과 메소드를 상속받아 사용 가능

### 체이닝

객체의 속성 참조시 속성이 없는 경우 프로토타입 체인 동작

`[[Prototype]]` 을 통해서 부모 객체를 탐색

모든 객체의 부모는 `Object.prototype`

### class

ES6에 클래스 기반 언어에 익숙한 개발자가 빠르게 학습할 수 있도록 class 문법이 추가됨

기존 프로토타입 기반 상속 매커니즘의 추상화

`class 클래스명 {}` 형태를 띔

class 내에는 메소드만 작성 가능

## Scope

변수가 유효성을 갖는 영역

- 스코프의 규칙
  - 렉시컬 스코프 규칙, dynamic
- 스코프의 종류
  - 전역, 모듈, file, 함수, 블럭 스코프
